blastx_Airr_Cvirg <- as.data.table(read.delim2(file="HPC_Analysis/output/F1_TagSeq/blastx/AirrProDB_CvirgNQuery/airradians_diamond_out", header=F)) %>%
`colnames<-`(c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
#(2) Cgigas protein database with Airradians nucleotide query
blastx_Airr_Cgig  <- as.data.table(read.delim2(file="HPC_Analysis/output/F1_TagSeq/blastx/CgigProDB_AirrNQuery/cgigas_diamond_out", header=F)) %>%
`colnames<-`(c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
blastx_Airr_Cvirg
nrow(raw.countmatrix) # 26595 total unique transcrips calls in A irradians count matrix
length(unique(blastx_Airr_Cvirg$sseqid)) # 19042 - Airradians transcripts - in blast x Airradiads Prot database  to Cvriginica nucleotide query
length(unique(blastx_Airr_Cgig$qseqid)) # 7046 - Airradians transcripts - in Cgigas protein database to Airradians nucleotide query
# go with the Cvirg blastx values - more hits to unique genes (~ 3x more!)
bybitscore  <- blastx_Airr_Cvirg[,.SD[which.max(bitscore)],by=sseqid] # max bitscore
length(unique(blastx_Airr_Cvirg$sseqid)) # 19042 - Airradians transcripts - in blast x Airradiads Prot database  to Cvriginica nucleotide query
nrow(raw.countmatrix) # 26595 total unique transcrips calls in A irradians count matrix
# go with the Cvirg blastx values - more hits to unique genes (~ 3x more!)
bybitscore  <- blastx_Airr_Cvirg[,.SD[which.max(bitscore)],by=sseqid] # max bitscore
length(unique(bybitscore$sseqid)) # 19042
length(unique(bybitscore$sseqid))  == length(unique(blastx_Airr_Cvirg$sseqid))# TRUE
nrow(bybitscore %>% dplyr::filter(sseqid %in% raw.countmatrix$transcript_id)) # 18874
byevalue    <- blastx_Airr_Cvirg[,.SD[which.min(evalue)],by=sseqid] # min evalue
length(unique(byevalue$sseqid)) # 19042
length(unique(byevalue$sseqid))  == length(unique(blastx_Airr_Cvirg$sseqid))# TRUE
nrow(byevalue %>% dplyr::filter(sseqid %in% raw.countmatrix$transcript_id)) # 18874
nrow(raw.countmatrix) / length(unique(blastx_Airr_Cvirg$sseqid))
(length(unique(blastx_Airr_Cvirg$sseqid)) / nrow(raw.countmatrix))* 100 #
# seq ID reference fr C virginica data
Cvirg_seqID <- Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID)
Cvirg_seqID
Cvirg_seqID
Cvirg_GOterms
# seq ID reference fr C virginica data
Cvirg_seqID <- Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID)
# seq ID reference fr C virginica data
Cvirg_seqID <- Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID)
# diamond result to obtain accession IDs of annotated genes Cvirg and Cgigas for gene ID, GO, and KEGG ID information
#(1) Airradians protein database (...pep.fna file) with Cvirginica nucleotide query
blastx_Airr_Cvirg <- as.data.table(read.delim2(file="HPC_Analysis/output/F1_TagSeq/blastx/AirrProDB_CvirgNQuery/airradians_diamond_out", header=F)) %>%
`colnames<-`(c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
#(2) Cgigas protein database with Airradians nucleotide query
blastx_Airr_Cgig  <- as.data.table(read.delim2(file="HPC_Analysis/output/F1_TagSeq/blastx/CgigProDB_AirrNQuery/cgigas_diamond_out", header=F)) %>%
`colnames<-`(c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore"))
# seq ID reference fr C virginica data
Cvirg_seqID <- Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID)
# due to the lack of annotation in the Airraians draft genome..
# call the Cvirginica database of protein names and transcript ID calls
Cvirg_seqID      <-  as.data.table(read.delim2(file = "RAnalysis/Data/Transcriptomics/seq_id.txt", header =F)) %>%
`colnames<-`("fullID")
Cvirg_GOterms    <-  read.csv(file = "RAnalysis/Data/Transcriptomics/Cviginiva_GOterms.csv", header =T) %>%
dplyr::select(c('GeneID','Annotation_GO_ID'))
# seq ID reference fr C virginica data
Cvirg_seqID <- Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID)
Cvirg_seqID
colnames(Cvirg_GOterms)
nrow(Cvirg_seqID)
nrow(Cvirg_GOterms)
merge(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
Cvirg_GOterms
cbind(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
merge(data.frame(Cvirg_seqID, row.names=NULL), data.frame(Cvirg_GOterms, row.names=NULL),
by = 0, all = TRUE)
Cvirg_seqIDMASTER <- merge(data.frame(Cvirg_seqID, row.names=NULL), data.frame(Cvirg_GOterms, row.names=NULL),
by = "GeneID", all = TRUE)
Cvirg_seqIDMASTER
nrow(Cvirg_seqIDMASTER)
Cvirg_seqID
Cvirg_seqIDMASTER <- merge(
data.frame(Cvirg_seqID, row.names=NULL),
data.frame(Cvirg_GOterms, row.names=NULL),
by = "GeneID")
nrow(Cvirg_seqIDMASTER)
Cvirg_seqID
Cvirg_GOterms
Cvirg_seqIDMASTER <- merge(
data.frame(Cvirg_seqID, row.names=NULL),
data.frame(Cvirg_GOterms, row.names=NULL),
by = "GeneID")
nrow(Cvirg_seqID)
nrow(Cvirg_GOterms)
nrow(Cvirg_seqIDMASTER)
Cvirg_seqIDMASTER
Cvirg_seqIDMASTER <- cbind(
data.frame(Cvirg_seqID, row.names=NULL),
data.frame(Cvirg_GOterms, row.names=NULL),
by = "GeneID")
full_join(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
Cvirg_seqIDMASTER <- full_join(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
Cvirg_seqIDMASTER
nrow(Cvirg_seqIDMASTER)
nrow(Cvirg_seqID)
# seq ID reference fr C virginica data
Cvirg_seqID <- as.data.frame(Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID))
# due to the lack of annotation in the Airraians draft genome..
# call the Cvirginica database of protein names and transcript ID calls
Cvirg_seqID      <-  as.data.table(read.delim2(file = "RAnalysis/Data/Transcriptomics/seq_id.txt", header =F)) %>%
`colnames<-`("fullID")
Cvirg_GOterms    <-  read.csv(file = "RAnalysis/Data/Transcriptomics/Cviginiva_GOterms.csv", header =T) %>%
dplyr::select(c('GeneID','Annotation_GO_ID'))
# seq ID reference fr C virginica data
Cvirg_seqID <- as.data.frame(Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID))
nrow(Cvirg_seqID)
Cvirg_seqID
Cvirg_seqIDMASTER <- full_join(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
nrow(Cvirg_seqIDMASTER)
View(Cvirg_seqID)
View(Cvirg_GOterms)
Cvirg_GOterms    <-  read.csv(file = "RAnalysis/Data/Transcriptomics/Cviginiva_GOterms.csv", header =T) %>%
dplyr::select(c('GeneID','Annotation_GO_ID')) %>%
unique()
Cvirg_GOterms
nrow(Cvirg_GOterms)
# due to the lack of annotation in the Airraians draft genome..
# call the Cvirginica database of protein names and transcript ID calls
Cvirg_seqID      <-  as.data.table(read.delim2(file = "RAnalysis/Data/Transcriptomics/seq_id.txt", header =F)) %>%
`colnames<-`("fullID")
nrow(Cvirg_seqID)
read.csv(file = "RAnalysis/Data/Transcriptomics/Cviginiva_GOterms.csv", header =T)
Cvirg_seqID
# seq ID reference fr C virginica data
Cvirg_seqID <- as.data.frame(Cvirg_seqID[Cvirg_seqID$fullID %like% "XM_", ]  %>% # call all mRNA samples - accession always starts with XM
dplyr::mutate(TranscriptID = (str_match(fullID, ">\\s*(.*?)\\s* PREDICTED:")[,2])) %>%
dplyr::mutate(ProteinID = sub('.*Crassostrea virginica ', '',(gsub("\\s\\(LOC.*|\\sLOC111.*", "", perl=TRUE, fullID))) ) %>%
dplyr::mutate(GeneID = paste('L', (gsub('),.*', '',(gsub(".*\\s\\(L", "", fullID)))), sep = '')) %>%
dplyr::select(-fullID))
Cvirg_seqID
cbind(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
Cvirg_seqIDMASTER <- full_join(Cvirg_seqID,Cvirg_GOterms, by = 'GeneID')
nrow(Cvirg_seqIDMASTER)
nrow(Cvirg_seqID)
nrow(Cvirg_seqIDMASTER)
nrow(Cvirg_GOterms)
nrow(Cvirg_seqIDMASTER)
Cvirg_seqIDMASTER
write.csv(Cvirg_seqIDMASTER, file = "RAnalysis/Data/TagSeq/seq_id_Cvirginica_master.csv", row.names = FALSE)
write.csv(Cvirg_seqIDMASTER, file = "RAnalysis/Data/Transcriptomics/seq_id_Cvirginica_master.csv", row.names = FALSE)
#
Cvirg_seqID      <-  read.csv(file = "RAnalysis/Data/Transcriptomics/seq_id_Cvirginica_master.csv", header =T) %>%
dplyr::rename(Cvirginica_TranscriptID = TranscriptID)
#
Airr.ID         <- as.data.frame(raw.countmatrix$transcript_id) %>% `colnames<-`("Airradians_TranscriptID")
Airr.ID
Cvirg_ID.evalue <- merge(Cvirg_seqID,
(byevalue   %>% dplyr::select(sseqid, qseqid) %>% `colnames<-`(c("Airradians_TranscriptID", "Cvirginica_TranscriptID"))),
by="Cvirginica_TranscriptID",
all=T) %>% `colnames<-`(c("blastxEval_CvirgTranscriptID", "blastxEval_CvirgProteinID", "blastxEval_CvirgGeneID", "Airradians_TranscriptID"))
Cvirg_ID.bitsc  <- merge(Cvirg_seqID,
(bybitscore %>% dplyr::select(sseqid, qseqid) %>% `colnames<-`(c("Airradians_TranscriptID", "Cvirginica_TranscriptID"))),
by="Cvirginica_TranscriptID",
all=T) %>% `colnames<-`(c("blastxBit_CvirgTranscriptID", "blastxBit_CvirgProteinID", "blastxBit_CvirgGeneID", "Airradians_TranscriptID"))
merge1  <- merge(Airr.ID,Cvirg_ID.evalue,by="Airradians_TranscriptID")  %>% dplyr::rename(GeneID = blastxEval_CvirgGeneID)
merge2  <- merge(merge1, Cvirg_ID.bitsc,by="Airradians_TranscriptID", all=T)
merge1
#
Airr.ID         <- as.data.frame(raw.countmatrix$transcript_id) %>%
`colnames<-`("Airradians_TranscriptID")
Airr.ID
Cvirg_ID.evalue
View(Cvirg_ID.evalue)
Cvirg_ID.evalue <- merge(Cvirg_seqID,
(byevalue   %>% dplyr::select(sseqid, qseqid) %>% `colnames<-`(c("Airradians_TranscriptID", "Cvirginica_TranscriptID"))),
by="Cvirginica_TranscriptID",
all=T) %>% `colnames<-`(c("blastxEval_CvirgTranscriptID",
"blastxEval_CvirgProteinID",
"blastxEval_CvirgGeneID",
"blastxEval_CvirgGOterms",
"Airradians_TranscriptID"))
Cvirg_ID.bitsc  <- merge(Cvirg_seqID,
(bybitscore %>% dplyr::select(sseqid, qseqid) %>% `colnames<-`(c("Airradians_TranscriptID", "Cvirginica_TranscriptID"))),
by="Cvirginica_TranscriptID",
all=T) %>% `colnames<-`(c("blastxBit_CvirgTranscriptID",
"blastxBit_CvirgProteinID",
"blastxBit_CvirgGeneID",
"blastxEval_CvirgGOterms",
"Airradians_TranscriptID"))
View(Cvirg_ID.evalue)
Airr.ID
merge1  <- merge(Airr.ID,Cvirg_ID.evalue,by="Airradians_TranscriptID")  %>% dplyr::rename(GeneID = blastxEval_CvirgGeneID)
merge1
View(merge1)
merge2  <- merge(merge1, Cvirg_ID.bitsc,by="Airradians_TranscriptID", all=T)
merge1  <- merge(Airr.ID,Cvirg_ID.evalue,by="Airradians_TranscriptID")  %>%
dplyr::rename(GeneID = blastxEval_CvirgGeneID)
merge1
merge1  <- merge(Airr.ID,Cvirg_ID.evalue,by="Airradians_TranscriptID")
# merge2  <- merge(merge1, Cvirg_ID.bitsc,by="Airradians_TranscriptID", all=T)
View(merge1)
# View(raw.countmatrix)
nrow(raw.countmatrix)
raw.countmatrix
# View(raw.countmatrix)
nrow(raw.countmatrix)
length(unique(blastx_Airr_Cvirg$sseqid))
# merge2  <- merge(merge1, Cvirg_ID.bitsc,by="Airradians_TranscriptID", all=T)
nrow(merge1)
Airr_Cvirg_master_seq_ID  <- merge(Airr.ID,Cvirg_ID.evalue,by="Airradians_TranscriptID")
# merge2  <- merge(merge1, Cvirg_ID.bitsc,by="Airradians_TranscriptID", all=T)
nrow(Airr_Cvirg_master_seq_ID) # 19168
(nrow(Airr_Cvirg_master_seq_ID) / nrow(raw.countmatrix))*100
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(dplyr)
library(edgeR)
BiocManager::install("edgeR")
library(edgeR)
library(cowplot)
library(ggplot2)
print(getwd())  # working directory is the scipts folder
# path for output ting all .csv filtered count files
path = 'C:/Users/samjg/Documents/Github_repositories/Airradians_multigen_OA/' # run this for all count matrix outputs!!!
print(getwd())  # working directory is the scipts folder
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# count matrix from prepDE.py script
# NOTE: aligned to the Airradians draft and unannotated genome!
raw.countmatrix  <- read.csv(file="HPC_Analysis/output/F1_TagSeq/Airradians_transcript_count_matrix.csv", header=T) # read the output count matrix - NOTE: TRIMMED at 30 phred threshold!
raw.countmatrix[is.na(raw.countmatrix)] <- 0 # replace all occurances of NA with 0
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref <- read.csv(file="Data/Transcriptomics/exp_metadata.csv", sep=',', header=TRUE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref <- read.csv(file="Data/Transcriptomics/exp.metadata.csv", sep=',', header=TRUE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref <- read.csv(file="\RAnalysis/Data/Transcriptomics/exp.metadata.csv", sep=',', header=TRUE)
print(getwd())  # working directory is the scipts folder
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref <- read.csv(file="/RAnalysis/Data/Transcriptomics/exp.metadata.csv", sep=',', header=TRUE)
print(getwd())  # working directory is the scipts folder
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref <- read.csv(file="C:/Users/samjg/Documents/Github_repositories/Airradians_multigen_OA/RAnalysis/Data/Transcriptomics/exp.metadata.csv", sep=',', header=TRUE)
smpl_ref
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
ncol(raw.countmatrix) # 282 samples (not counting gene ID column) - should be 141 samples, need to sum columns by unique ID
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw.countmatrix
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.merged <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are numeric
raw_counts.merged
names(raw_counts.merged)
names(raw_counts.merged) <- sapply(strsplit(names(raw_counts.merged), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
raw_counts.merged
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.editted
# (1) true matrix - change transcript Ids to rownames
raw_counts.editted <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are numeric
raw_counts.editted
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# (2) edit the column names (sampe IDs) to the shortened form (i.e. Ai1, Ai2, etc.)
# this will match out exp_metadata file to merge later
names(raw_counts.editted) <- sapply(strsplit(names(raw_counts.editted), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.transposed <- t(rowsum(t(raw_counts.editted), group = colnames(raw_counts.editted), na.rm = TRUE)) # merge all unique columns and sum counts
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
ncol(raw_counts.transposed) # now 141 samples
raw_counts.transposed
t(raw_counts.editted)
raw.countmatrix[is.na(raw.countmatrix)] <- 0 # replace all occurances of NA with 0
ncol(raw.countmatrix) # 78 samples (not counting transcript_id column) - should be 36 per treatment
# (1) true matrix - change transcript Ids to rownames
raw_counts.editted <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are transcript Ids
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
nrow(raw_counts.editted)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
ncol(raw_counts.editted)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# (2) edit the column names (sampe IDs) to the shortened form (i.e. Ai1, Ai2, etc.)
# this will match out exp_metadata file to merge later
names(raw_counts.editted) <- sapply(strsplit(names(raw_counts.editted), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
# (1) true matrix - change transcript Ids to rownames
raw_counts.editted <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are transcript Ids
ncol(raw_counts.editted) # 78 - now that the transcript IDs are rownames
# (2) edit the column names (sampe IDs) to the shortened form (i.e. Ai1, Ai2, etc.)
# this will match out exp_metadata file to merge later
names(raw_counts.editted) <- sapply(strsplit(names(raw_counts.editted), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.matrix <-as.matrix(raw_counts.editted, row.names="transcript_id") # call dataframe as matrix
raw_counts.matrix
# (1) true matrix - change transcript Ids to rownames
raw_counts.editted <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are transcript Ids
raw_counts.editted
ncol(raw_counts.editted) # 78 - now that the transcript IDs are rownames
names(raw_counts.editted)
# (2) edit the column names (sampe IDs) to the shortened form (i.e. Ai1, Ai2, etc.)
# this will match out exp_metadata file to merge later
names(raw_counts.editted) <- sapply(strsplit(names(raw_counts.editted), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
names(raw_counts.editted)
raw_counts.transposed <- t(rowsum(t(raw_counts.editted), group = colnames(raw_counts.editted), na.rm = TRUE)) # merge all unique columns and sum counts
ncol(raw_counts.transposed) # now 141 samples
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
names(raw_counts.transposed)
raw_counts.transposed
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
View(raw_counts.transposed)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
View(raw_counts.editted)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
colnames(raw_counts.editted)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
ncol(raw_counts.transposed) # now 141 samples
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
colnames(raw_counts.transposed)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.matrix <-as.matrix(raw_counts.transposed, row.names="transcript_id") # call dataframe as matrix
raw_counts.matrix
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
View(raw_counts.matrix)
ncol(raw_counts.matrix) # 141 samples
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
nrow(raw_counts.matrix) # 34947 total genes
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# READ COUNTS
dim(raw_counts.matrix) # 34947 total genes 141 samples
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
sum(raw_counts.matrix) # 113637063 total read counts
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
gene_sums <- data.frame(rowSums(raw_counts.matrix))  # all gene.IDs and the sum of unique reads
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
transcript_sums <- colSums(raw_counts.matrix) # sum of reads for each sample
mean(transcript_sums) # 805936.6 == average raw read counts for each sample
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
sd(transcript_sums) # 165380.6 == standard deviation of raw read counts per sample
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
gene_sums_gtr0 <- rowSums(raw_counts.matrix) > 0 # all gene.IDs with at least one unique read
sum(gene_sums_gtr0 == TRUE) # 29318 total genes with unique transcript reads
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
( sum(gene_sums_gtr0 == TRUE) / (dim(raw_counts.matrix)[1]) ) *100 # 83.89275 % of genes have a unique mapped read
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# For loop ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;;; #
df_total <- data.frame() # start dataframe
loop.table <- data.frame(matrix(nrow = 4, ncol = 4)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('CPM_threshold', 'Day', 'total_genes', 'mean_reads_per_gene') # names for comuns in the for loop
CPM_loop <- c(0:50)
CPM_loop <- data.frame(CPM_loop)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.as.table <- data.frame(transcript_id = row.names(raw_counts.transposed), raw_counts.transposed) # add back the rownames 'transcript_ID'
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(raw_counts.transposed) <- NULL # ommit the rownames
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
ncol(raw_counts.transposed) # 142 counting the transcript.ID that we want to keep!
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.transposed
row.names(raw_counts.transposed)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# (1) true matrix - change transcript Ids to rownames
raw_counts.merged <- data.frame(raw.countmatrix[,-1], row.names=raw.countmatrix[,1]) # call new dataframe with first column now as row names, now all row values are transcript Ids
ncol(raw_counts.merged) # 78 - now that the transcript IDs are rownames
# (2) edit the column names (sampe IDs) to the shortened form (i.e. Ai1, Ai2, etc.)
# this will match out exp_metadata file to merge later
names(raw_counts.merged) <- sapply(strsplit(names(raw_counts.merged), "_"), '[', 1) # split the column names by "_" delimiter  and call the first field SG##
colnames(raw_counts.merged) # you see we have pairs for each - as these are paired-end reads!
# (3) sum together all rows grouped by common column name
# basically this adds together the paired-end data within sample
raw_counts.merged <- t(rowsum(t(raw_counts.merged),
group = colnames(raw_counts.merged),
na.rm = TRUE)) # merge all unique columns and sum counts
ncol(raw_counts.merged) # 39 total samples
# now call as a matrix
raw_counts.matrix <-as.matrix(raw_counts.merged,
row.names="transcript_id") # call dataframe as matrix
ncol(raw_counts.matrix) # 39 samples
nrow(raw_counts.matrix) # 26595 total genes
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.as.table <- data.frame(transcript_id = row.names(raw_counts.merged), raw_counts.merged) # add back the rownames 'transcript_ID'
rownames(raw_counts.transposed) <- NULL # ommit the rownames
ncol(raw_counts.transposed) # 39 counting the transcript.ID that we want to keep!
raw_counts.as.table <- data.frame(transcript_id = row.names(raw_counts.merged), raw_counts.merged) # add back the rownames 'transcript_ID'
row.names(raw_counts.merged)
ncol(raw_counts.transposed) # 39 counting the transcript.ID that we want to keep!
rownames(raw_counts.transposed) <- NULL # ommit the rownames
ncol(raw_counts.transposed) # 39 counting the transcript.ID that we want to keep!
raw_counts.transposed
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(raw_counts.as.table) <- NULL # ommit the rownames
ncol(raw_counts.as.table) # 39 counting the transcript.ID that we want to keep!
raw_counts.as.table
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
smpl_ref
raw.countmatrix
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
unique(colnames(raw.countmatrix))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
unique(names(raw_counts.merged))
names(raw_counts.merged)
raw_counts.merged
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
unique(sapply(strsplit(names(raw.countmatrix), "_"), '[', 1))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
raw_counts.as.table[,c(1,na.omit(match(smpl_ref$SampleName_readmatrix, colnames(raw_counts.as.table))))]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# ==========================================================
#
# DAY 0
# ==========================================================
cts.merged <- raw_counts.as.table[,c(1,na.omit(match(smpl_ref$SampleName_readmatrix, colnames(raw_counts.as.table))))]
cts.merged
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# ==========================================================
#
# DAY 0
# ==========================================================
cts.merged     <- raw_counts.as.table[,c(1,na.omit(match(smpl_ref$SampleName_readmatrix, colnames(raw_counts.as.table))))]
cts.merged     <- data.frame(cts.merged[,-1], row.names=cts.merged[,1])
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
cts.matrix     <- as.matrix(cts.merged, row.names="transcript_id")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
CPM            <- cpm(cts.matrix) # Obtain CPMs (counts oer million) using egdeR
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
thresh         <- CPM > var # Which values in myCPM are greater than 3?
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
for (i in 1:nrow(CPM_loop)) {
var <- CPM_loop[i,1]
cts.merged     <- raw_counts.as.table[,c(1,na.omit(match(smpl_ref$SampleName_readmatrix, colnames(raw_counts.as.table))))]
cts.merged     <- data.frame(cts.merged[,-1], row.names=cts.merged[,1])
cts.matrix     <- as.matrix(cts.merged, row.names="transcript_id")
CPM            <- cpm(cts.matrix) # Obtain CPMs (counts oer million) using egdeR
thresh         <- CPM > var # Which values in myCPM are greater than 3?
keep           <- rowSums(thresh) >= (ncol(thresh)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
rowSums(head(thresh)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh)) # 6880 genes with TRUE in all 36 samples
cts.matrix.LOOPED <- cts.matrix[keep,]
total_genes           <- nrow(cts.matrix.LOOPED)
mean_reads_per_gene   <- mean( (rowSums(cts.matrix.LOOPED) / ncol(cts.matrix.LOOPED) ) )
}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# For loop ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;;; #
df_total <- data.frame() # start dataframe
loop.table <- data.frame(matrix(nrow = 1, ncol = 3)) # create dataframe to save cumunalitively during for loop
colnames(loop.table)<-c('CPM_threshold',
'total_genes',
'mean_reads_per_gene') # names for comuns in the for loop
CPM_loop <- c(0:50)
CPM_loop <- data.frame(CPM_loop)
for (i in 1:nrow(CPM_loop)) {
var <- CPM_loop[i,1]
cts.merged     <- raw_counts.as.table[,c(1,na.omit(match(smpl_ref$SampleName_readmatrix, colnames(raw_counts.as.table))))]
cts.merged     <- data.frame(cts.merged[,-1], row.names=cts.merged[,1])
cts.matrix     <- as.matrix(cts.merged, row.names="transcript_id")
CPM            <- cpm(cts.matrix) # Obtain CPMs (counts oer million) using egdeR
thresh         <- CPM > var # Which values in myCPM are greater than 3?
keep           <- rowSums(thresh) >= (ncol(thresh)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
rowSums(head(thresh)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh)) # 6880 genes with TRUE in all 36 samples
cts.matrix.LOOPED <- cts.matrix[keep,]
total_genes           <- nrow(cts.matrix.LOOPED)
mean_reads_per_gene   <- mean( (rowSums(cts.matrix.LOOPED) / ncol(cts.matrix.LOOPED) ) )
loop.table$CPM_threshold         <- var
loop.table$total_genes           <- total_genes
loop.table$mean_reads_per_gene   <- mean_reads_per_gene
df <- data.frame(loop.table) # name dataframe for this singl e row
df_total <- rbind(df_total,df) #bind to a cumulative list dataframe
print(df_total) # print to monitor progress
}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
df_total
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
Filterfig <- df_total %>%
tidyr::gather(key = "variable", value = "measurement",
total_genes, mean_reads_per_gene, -Day) %>%
# Start with a usual ggplot2 call:
ggplot(aes(x = CPM_threshold)) +
geom_line(aes(y = measurement)) +
ggtitle("Day 0") +
geom_vline(xintercept = c(3,5,10), color = 'red') +
facet_wrap(. ~ variable, scales="free")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
Filterfig <- df_total %>%
tidyr::gather(key = "variable", value = "measurement",
total_genes, mean_reads_per_gene) %>%
# Start with a usual ggplot2 call:
ggplot(aes(x = CPM_threshold)) +
geom_line(aes(y = measurement)) +
ggtitle("Day 0") +
geom_vline(xintercept = c(3,5,10), color = 'red') +
facet_wrap(. ~ variable, scales="free")
Filterfig
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
print(df_total)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
print(Filterfig)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
#df_total # view the loop data
Filterfig <- df_total %>%
tidyr::gather(key = "variable", value = "measurement",
total_genes, mean_reads_per_gene) %>%
# Start with a usual ggplot2 call:
ggplot(aes(x = CPM_threshold)) +
geom_line(aes(y = measurement)) +
geom_vline(xintercept = c(3,5,10), color = 'red') +
facet_wrap(. ~ variable, scales="free")
print(Filterfig)
